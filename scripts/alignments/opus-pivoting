#!/usr/bin/perl
#-*-perl-*-
#

use strict;

use File::Basename;
use Getopt::Long;
use Data::Dumper;
use Sort::Naturally qw/nsort/;

my $help = 0;
my $verbose = 0;
my $scorefilter = "";
my $alignall = 0;
my $emptylinks = 0;

# FIXME: implement getting all alignments
# FIXME: take score into account
# FIXME: score filter? Depends on source data, so need both XML attribute and value
#  - might also auto-detect the attribute (usually there aren't that many)

GetOptions(
    "help|h" => \$help,
    "verbose|v" => \$verbose,
    "scorefilter|s" => \$scorefilter,
    "alignall|a" => \$alignall,
    "emptylinks|e" => \$emptylinks,
    );

my $algfile1 = shift;
my $algfile2 = shift;

if ($help || !($algfile1 && $algfile2)) {
    &pivoting_usage()
}

if (! -f $algfile1) {
    die "Not a file: $algfile1"
}

if (! -f $algfile2) {
    die "Not a file: $algfile2"
}

my $base1 = basename($algfile1);
my $base2 = basename($algfile2);

$base1 =~ s/\.xml(\.gz)//;
$base2 =~ s/\.xml(\.gz)//;

my ($src1,$trg1) = split(/\-/,$base1);
my ($src2,$trg2) = split(/\-/,$base2);

my $pivot = undef;
if ($src1 eq $src2){
    $pivot = $src1;
}
elsif ($src1 eq $trg2){
    $pivot = $src1;
}
elsif ($trg1 eq $src2){
    $pivot = $trg1;
}
elsif ($trg1 eq $trg2){
    $pivot = $trg1;
}
else{
    die "no pivot language found";
}

if ($algfile1 =~ /\.gz/){
    open(F,"gzip -cd < $algfile1 |") || die "cannot read from $algfile1";
}
else{
    open(F,"<$algfile1") || die "cannot read from $algfile1";
}

print STDERR "read links from $algfile1 ...\n";


sub get_links_from_file {

    my ($file, $pivot_src) = @_;

    my $fh;

    if ($file =~ /\.gz/){
        open($fh, "gzip -cd < $file |") || die "cannot read from $file";
    }
    else{
        open($fh, "<$file") || die "cannot read from $file";
    }

    print STDERR "read links from $file ...\n";

    # FIXME: use XML::Parser (or equivalent) to read the XML fie
    my $links = {};
    my $fromDoc = undef;
    my $toDoc = undef;

    while (<$fh>){
        if (/fromDoc=\"([^\"]+)\"/){
            $fromDoc=$1;
        }
        if (/toDoc=\"([^\"]+)\"/){
            $toDoc=$1;
        }

        if (/xtargets=\"([^\"]+)\"/){
            my $link = $1;
            my ($s,$t) = split(/\;/,$link);
            if ($pivot_src){
                # Ignore links where source does not have an alignment
                if ($s =~ /^\s*$/ || $t =~ /^\s*$/) {
                    next unless $emptylinks;
                }
                # Use an array to store the links - may have multiple
                if (exists($links->{$fromDoc}{$s})) {
                    push @{$links->{$fromDoc}{$s}}, "$toDoc:$t"
                }
                else {
                    $links->{$fromDoc}{$s} = ["$toDoc:$t"];
                }
            }
            else{
                # Ignore links where target does not have an alignment
                if ($s =~ /^\s*$/ || $t =~ /^\s*$/) {
                    next unless $emptylinks;
                }
                if (exists($links->{$toDoc}{$t})) {
                    push @{$links->{$toDoc}{$t}}, "$fromDoc:$s"
                }
                else {
                    $links->{$toDoc}{$t} = ["$fromDoc:$s"];
                }
            }
        }
    }

    close($fh);

    return $links;
}

# print STDERR ($pivot, $src1),"\n";
my $links1 = get_links_from_file($algfile1, $pivot eq $src1 ? 1 : 0);
# print STDERR Dumper($links1);

my $links2 = get_links_from_file($algfile2, $pivot eq $src2 ? 1 : 0);
# print STDERR Dumper($links2);

print '<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE cesAlign PUBLIC "-//CES//DTD XML cesAlign//EN" "">
<cesAlign version="1.0">
';

my $currentFromDoc = undef;
my $currentToDoc = undef;

my $fromDoc = undef;
my $toDoc = undef;

foreach my $s_doc (keys %$links2) {
    if (exists($links1->{$s_doc})) {
#        foreach my $s_align (sort { $a cmp $b } keys %{$links2->{$s_doc}}) {
        foreach my $s_align (nsort keys %{$links2->{$s_doc}}) {
            if (exists($links1->{$s_doc}->{$s_align})) {
#                printf STDERR "%s: %s\n", $s_doc, $s_align;
                my @talignments;
                my @salignments;
                foreach my $alignment (@{$links2->{$s_doc}->{$s_align}}) {
                    push @talignments, $alignment;
                }
                foreach my $alignment (@{$links1->{$s_doc}->{$s_align}}) {
                    push @salignments, $alignment;
                }

                # Here we have listed all possible alignments
                # FIXME: check whether there are multiple alignments
                # FIXME: handle scoring in case of multiple alignments

                foreach my $a1 (@talignments) {
                    my ($t_doc, $t_align) = split(/:/, $a1);
#                    printf STDERR "%s: %s\n", $t_doc, $t_align;

                    foreach my $a2 (@salignments) {
                        my ($st_doc, $st_align) = split(/:/, $a2);
#                        printf STDERR " %s: %s\n", $st_doc, $st_align;

                        if ($currentFromDoc ne $st_doc || $currentToDoc ne $t_doc){
                            if ($currentFromDoc){
                                print "</linkGrp>\n";
                            }
                            print "<linkGrp targType=\"s\" fromDoc=\"$st_doc\" toDoc=\"$t_doc\">\n";
                            $currentFromDoc = $st_doc;
                            $currentToDoc = $t_doc;
                        }
                        print '  <link xtargets="',$st_align,';',$t_align,'" />',"\n";
                    }
                }
            }
        }
    }
    else {
#        print STDERR "No such doc in first alignment file: $s_doc\n";
    }
}

if ($currentFromDoc){
    print "</linkGrp>\n";
}
print "</cesAlign>\n";


sub pivoting_usage {

die <<USAGE_END

Usage: $0 <options> alignment_file1 alignment_file2

Pivot alignment using two XCES alignment files. Produces another XCES alignment file as a result.

Options
 -v  | -verbose   Verbose
 -h  | -help      This help

USAGE_END

}
