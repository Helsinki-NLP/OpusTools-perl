#!/usr/bin/perl
#-*-perl-*-
#

use strict;

use File::Basename;
use Getopt::Long;
use Data::Dumper;
#use Sort::Naturally qw/nsort/;

my $help = 0;
my $verbose = 0;
my $emptylinks = 0;
my $scorefilter = ""; # unused for now
my $scoreattribute = "";
my $calcscore = 0;
my $alignall = 0;
my $topn = 0;

# Use only a subset of data - for testing
my $numlinks = 0;

# FIXME: score filter? Depends on source data, so need both XML attribute and value
#  - might also auto-detect the attribute (usually there aren't that many)

GetOptions(
    "help|h" => \$help,
    "verbose|v" => \$verbose,
    "alignall|a" => \$alignall,
    "emptylinks|e" => \$emptylinks,
    "scoreattribute|t:s" => \$scoreattribute,
    "scorefilter|s" => \$scorefilter,
    "calcscore|c" => \$calcscore,
    "topn|n:i" => \$topn,
    "numlinks|l:i" => \$numlinks,
    );

my $algfile1 = shift;
my $algfile2 = shift;

if ($help || !($algfile1 && $algfile2)) {
    &pivoting_usage()
}

if (! -f $algfile1) {
    die "Not a file: $algfile1"
}

if (! -f $algfile2) {
    die "Not a file: $algfile2"
}

my $base1 = basename($algfile1);
my $base2 = basename($algfile2);

$base1 =~ s/\.xml(\.gz)//;
$base2 =~ s/\.xml(\.gz)//;

my ($src1,$trg1) = split(/\-/,$base1);
my ($src2,$trg2) = split(/\-/,$base2);

my $pivot = undef;
if ($src1 eq $src2){
    $pivot = $src1;
}
elsif ($src1 eq $trg2){
    $pivot = $src1;
}
elsif ($trg1 eq $src2){
    $pivot = $trg1;
}
elsif ($trg1 eq $trg2){
    $pivot = $trg1;
}
else{
    die "no pivot language found";
}

if ($topn && !$scoreattribute) {
    print STDERR "No score attribute specified - top N filtering disabled\n";
    $topn = 0;
}

if ($verbose) {
    if ($scoreattribute) {
        print STDERR "Using scoreattribute: $scoreattribute\n";
    }
    if ($alignall) {
        print STDERR "Getting all alignments\n";
    }
    elsif ($topn) {
        print STDERR "Getting top $topn alignments\n";
    }
}

sub get_links_from_file {

    my ($file, $pivot_src) = @_;

    my $fh;

    if ($file =~ /\.gz/){
        open($fh, "gzip -cd < $file |") || die "cannot read from $file";
    }
    else{
        open($fh, "<$file") || die "cannot read from $file";
    }

    print STDERR "read links from $file ...\n";

    # FIXME: use XML::Parser (or equivalent) to read the XML fie
    my $links = {};
    my $scores = {};

    my $fromDoc = undef;
    my $toDoc = undef;

    my $linkcount = 0;

    while (<$fh>){

        my $score = undef;

        if (/fromDoc=\"([^\"]+)\"/){
            $fromDoc=$1;
        }
        if (/toDoc=\"([^\"]+)\"/){
            $toDoc=$1;
        }

        if ($scoreattribute &&
            /$scoreattribute=\"([^\"]+?)\"/){
            $score = $1;
        }

        if (/xtargets=\"([^\"]+)\"/){
            my $link = $1;
            my ($s,$t) = split(/\;/,$link);

            # Ignore links without source or target alignment
            if ($s =~ /^\s*$/ || $t =~ /^\s*$/) {
                next unless $emptylinks;
            }

            if ($pivot_src){
                # Use an array to store the links - may have multiple
                if (exists($links->{$fromDoc}{$s})) {
                    # Assume descending order based on score - assume that first instance is the best

                    # Record all links if we want them all or just top N
                    # With top N, the filtering is done later
                    #  - Getting top N links only supported if we have a score
                    if ($alignall || ($topn && defined($score))) {
                        push @{$links->{$fromDoc}{$s}}, "$toDoc:$t";
                    }
                }
                else {
                    $links->{$fromDoc}{$s} = ["$toDoc:$t"];
                }
                if ($score) {
                    $scores->{$fromDoc}{$s}{"$toDoc:$t"} = $score;
                }
            }
            else{
                if (exists($links->{$toDoc}{$t})) {
                    # Assume descending order based on score - assume that first instance is the best
                    if ($alignall || ($topn && defined($score))) {
                        push @{$links->{$toDoc}{$t}}, "$fromDoc:$s";
                    }
                }
                else {
                    $links->{$toDoc}{$t} = ["$fromDoc:$s"];
                }
                if ($score) {
                    $scores->{$toDoc}{$t}{"$fromDoc:$s"} = $score;
                }
            }
        }
        $linkcount += 1;
        if ($numlinks && $linkcount >= $numlinks) {
            last;
        }
    }

    close($fh);

    return $links, $scores;
}

my ($links1, $scores1) = get_links_from_file($algfile1, $pivot eq $src1 ? 1 : 0);
#print STDERR Dumper($links1);
#print STDERR Dumper($scores1);

my ($links2, $scores2) = get_links_from_file($algfile2, $pivot eq $src2 ? 1 : 0);
#print STDERR Dumper($links2);
#print STDERR Dumper($scores2);

print '<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE cesAlign PUBLIC "-//CES//DTD XML cesAlign//EN" "">
<cesAlign version="1.0">
';

my $currentFromDoc = undef;
my $currentToDoc = undef;

my $fromDoc = undef;
my $toDoc = undef;

foreach my $s_doc (sort keys %$links2) {
    if (exists($links1->{$s_doc})) {
        foreach my $s_align (sort keys %{$links2->{$s_doc}}) {
#        foreach my $s_align (nsort keys %{$links2->{$s_doc}}) {
            if (exists($links1->{$s_doc}->{$s_align})) {
#                printf STDERR "%s: %s\n", $s_doc, $s_align;
                my @talignments;
                my @salignments;
                foreach my $alignment (@{$links2->{$s_doc}->{$s_align}}) {
                    push @talignments, $alignment;
                }
                foreach my $alignment (@{$links1->{$s_doc}->{$s_align}}) {
                    push @salignments, $alignment;
                }

#                if (scalar @salignments > 1) {
#                    print STDERR "Multiple source alignments: $s_doc $s_align\n"
#                }

#                if (scalar @talignments > 1) {
#                    print STDERR "Multiple target alignments: $s_doc $s_align\n"
#                }

                # List of alignments to produce
                my $include = [];

                # Scores for combinations
                my $al_scores = {};
                # Whether to do include links based on scores
                my $score_align = 0;

                foreach my $a2 (@talignments) {

                    my ($t_doc, $t_align) = split(/:/, $a2);

                    foreach my $a1 (@salignments) {
                        
                        # Alignment based on score only if we have chosen top N links
                        # Otherwise we assume that whatever input we have at this point is the final one
                        if ($topn &&
                               exists($scores1->{$s_doc}->{$s_align}->{$a1}) &&
                               exists($scores2->{$s_doc}->{$s_align}->{$a2})) {

                            $score_align = 1;
                            my $score1 = $scores1->{$s_doc}->{$s_align}->{$a1};
                            my $score2 = $scores2->{$s_doc}->{$s_align}->{$a2};

                            # Scores are float numbers that may be positive or negative - use addition instead of multiplication
                            $al_scores->{$a1 . '--' . $a2} = $score1 + $score2;
                        }
                        else {
                            my ($st_doc, $st_align) = split(/:/, $a1);

                            push @$include, [$st_doc, $st_align, $t_doc, $t_align, undef];
                        }
                    }
                }

                if ($score_align) {
                    # Get top N links
                    my @sorted_keys = sort { $al_scores->{$b} <=> $al_scores->{$a} } keys %$al_scores;
                    my @topn = @sorted_keys;

                    # Do we have more links than we want?
                    if ($#sorted_keys >= $topn) {
                        @topn = @sorted_keys[0..$topn-1];
                    }
                    #print STDERR Dumper($al_scores);
                    #print STDERR Dumper(\@sorted_keys);
                    #print STDERR Dumper(\@topn);

                    foreach my $elem (@topn) {
                        my ($a1, $a2) = split('--', $elem);
                        my ($st_doc, $st_align) = split(/:/, $a1);
                        my ($t_doc, $t_align) = split(/:/, $a2);

                        my $score = $al_scores->{$elem};

                        push @$include, [$st_doc, $st_align, $t_doc, $t_align, $score];
                    }
                }

                #print STDERR Dumper $include;
                foreach my $align (@$include) {
                    my ($st_doc, $st_align, $t_doc, $t_align, $_score) = @$align;

                    if ($currentFromDoc ne $st_doc || $currentToDoc ne $t_doc){
                        if ($currentFromDoc){
                            print "</linkGrp>\n";
                        }
                        print "<linkGrp targType=\"s\" fromDoc=\"$st_doc\" toDoc=\"$t_doc\">\n";
                        $currentFromDoc = $st_doc;
                        $currentToDoc = $t_doc;
                    }
                    if ($scoreattribute && $_score && $calcscore) {
                        printf("  <link xtargets=\"%s;%s\" %s=\"%s\"/>\n", $st_align, $t_align, $scoreattribute, $_score);
                    }
                    else {
                        printf("  <link xtargets=\"%s;%s\" />\n", $st_align, $t_align);
                    }
                }
            }
        }
    }
    else {
#        print STDERR "No such doc in first alignment file: $s_doc\n";
    }
}

if ($currentFromDoc){
    print "</linkGrp>\n";
}
print "</cesAlign>\n";

if ($verbose) {
    print STDERR "done\n"
}


sub pivoting_usage {

die <<USAGE_END

Usage: $0 <options> alignment_file1 alignment_file2

Pivot alignment using two XCES alignment files. Produces another XCES alignment file as a result.

Options
 -v       | --verbose               Verbose
 -h       | --help                  This help
 -a       | --all                   Get all links
 -n <n>   | --topn <n>              Get top N links (based on combined score)
 -t <att> | --scoreattribute <att>  Score attribute to use for score filtering

Debug options
 -l <n>   | --numlinks <n>          Only get N first links

USAGE_END

}
